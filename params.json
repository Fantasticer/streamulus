{"name":"Streamulus","body":"### In A Nutshell\r\n\r\nContinuous computations over event streams require a data structure (typically a graph) that describes how the input streams are to be processed. A language for specifying such a computation would ideally hide the construction of the graph from the user.\r\n\r\nGeneral purpose programming languages such as Java and C++ are considered to be ill suited for such tasks, prompting event processing systems such as StreamBase and Esper to support one of the variations of StreamSQL, i.e., a language that augments SQL by adding sliding window semantics as well as the possibility to write user-defined operators and embed them in continuous queries. These languages are very useful for many applications. Like SQL, they can be learned by non-programmers and used relatively easily. \r\n\r\nStreamulus takes a different approach to the stream programming problem. It is a C++ domain-specific embedded language (DSEL), meaning that the statements of the language are written in valid C++ syntax. The programmer needs to specify only what happens to a single event of the stream. For example, if x and y are streams, the expression (x+y)/2 is the stream of point-wise averages of x and y. The task of constructing the computation graph is delegated to the C++ compiler.  This magic is achieved by use of template metaprogramming techniques via the Boost Proto library.\r\n\r\nStreamulus is not intended as a replacement for the StreamSQL based systems. Its target users are C++ programmers who build real-time systems and need a lightweight tool that simplifies the task of writing stream processing code. For those users, it offers an expressive language for efficient stream computations.\r\n\r\n### An Example\r\n\r\nThe following program defines a continuous computation over two streams of numbers (of type double), labeled X and Y. It continuously computes the value of x/(x+y).\r\n\r\n    #include \"streamulus.h\"\r\n\r\n    int main()\r\n    {\r\n        using namespace streamulus;\r\n\r\n        // Set up some stream variables\r\n        InputStream<double>::type x = NewInputStream<double>((\"X\");\r\n        InputStream<double>::type y = NewInputStream<double>(\"Y\");\r\n\r\n        // Subscribe the query with the engine\r\n        Streamulus streamulus_engine;\r\n        streamulus_engine.Subscribe( x / (x + y) );\r\n    }\r\n\r\n \r\nIn Subscribe(), the expression is transformed into the following graph:\r\n\r\n![Graph generated for X/(X+Y)](https://github.com/iritkatriel/streamulus/raw/master/doc/SimpleExampleGraph.jpg)\r\n\r\nThen, we insert data to the input streams as follows:\r\n\r\n            InputStreamPut(x,5);\r\n            InputStreamPut(y,12);\r\n\r\n            InputStreamPut(x,23);\r\n            InputStreamPut(x,4);\r\n\r\n\r\nWhenever new data is inserted as above, it is automatically propagated through the graph. \r\n\r\n\r\n### User-Defined Nodes\r\n\r\nThe example above is not very useful because we are not doing anything with the computed values. However, graph nodes can apply user-defined transformations. They can have any side effect whatsoever such as displaying values on the screen, storing data in a database, and so on.\r\n\r\nFor example, this is how you can define an expression that takes a stream of strings and returns a stream of their lengths, while alerting us in case there are too many empty strings in the stream:\r\n\r\n    struct string_length\r\n    {        \r\n        string_length() \r\n            : num_empty(0) \r\n        {\r\n        }\r\n\r\n        template<typename Sig>\r\n        struct result\r\n        {\r\n            typedef size_t type;  \r\n        };\r\n    \r\n        size_t operator()(const std::string& s) const\r\n        { \r\n            if (s.size() == 0)\r\n                num_empty++;\r\n\r\n            if (num_empty > 100)\r\n                std::cout << \"There are many empty strings\" << std::endl;\r\n\r\n            return s.size(); \r\n        }\r\n    private:\r\n        int num_empty;\r\n    };\r\n\r\n\r\nYou can then use the \r\n \r\n    Streamify<string_length> \r\n\r\noperator in expressions. The Streamify template turns a point-computation function into one that performs the same computation continuously on a streamulus data stream:\r\n\r\n    InputStream<std::string>::type x(\"X\");\r\n    Streamulus streamulus_engine;\r\n    streamulus_engine.Subscribe(Streamify<string_length>( x )); \r\n\r\nThere is also support for common sub-expressions (graphs with nodes of outdegree>1), filter nodes, and other constructs. \r\n\r\n### Design Goals\r\n\r\n* Simple syntax for specifying computation graphs (as close as possible to the syntax of the same computation on scalar values). \r\n* Efficiency. The resulting graph should perform the computation as efficiently as possible. Low compilation time is a secondary concern.\r\n* No wait-loop. When data is not passing through the pipes, streamulus does not take up any CPU resources.\r\n\r\n### Status\r\n\r\nStreamulus is open sourced on github under the GNU v3 licence. \r\n\r\nIt is a research prototype. The first release will be coming soon.\r\n\r\nFollow @streamulus on twitter for updates about the projects (releases, documentation, etc).\r\n\r\n### Thanks\r\n\r\nStreamulus relies on Boost Proto library. \r\nI am grateful to Joel Falcou for his ongoing assistance and feedback. \r\n\r\nIrit Katriel  \r\n","tagline":"A C++ DSEL for real-time event stream processing","google":"UA-30902782-1","note":"Don't delete this file! It's used internally to help with page regeneration."}